<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OPUS Water Engine â€” Groups 1â€“8 Complete (All 17 Passes)</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;font-family:'Segoe UI',system-ui,sans-serif;color:#fff}
canvas{display:block;width:100vw;height:100vh}
#ui{position:fixed;top:10px;left:10px;z-index:10;pointer-events:none}
#ui>div{pointer-events:auto}
.panel{background:rgba(0,0,0,.82);border:1px solid rgba(100,180,255,.3);border-radius:8px;padding:10px 14px;margin-bottom:8px;font-size:12px;backdrop-filter:blur(6px);min-width:260px}
.panel h3{color:#6bf;margin-bottom:6px;font-size:13px;letter-spacing:.5px}
.row{display:flex;justify-content:space-between;align-items:center;margin:3px 0}
.row label{color:#aac}
.row span{color:#fff;font-weight:600;font-variant-numeric:tabular-nums}
.btn{background:rgba(100,180,255,.15);border:1px solid rgba(100,180,255,.4);color:#8cf;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;margin:2px}
.btn:hover{background:rgba(100,180,255,.3)}
.btn.active{background:rgba(100,200,100,.25);border-color:rgba(100,200,100,.5);color:#8f8}
select{background:#1a1a2e;color:#8cf;border:1px solid rgba(100,180,255,.3);padding:3px 6px;border-radius:3px;font-size:11px}
.gate{padding:2px 6px;border-radius:3px;font-size:10px;font-weight:700}
.gate.pass{background:rgba(0,200,0,.2);color:#0f0}
.gate.fail{background:rgba(200,0,0,.2);color:#f66}
.gate.wait{background:rgba(200,200,0,.15);color:#ff0}
#perf-bars{margin-top:6px}
.pbar{height:12px;margin:1px 0;border-radius:2px;display:flex;align-items:center;padding-left:4px;font-size:9px;color:#fff;min-width:2px;transition:width .3s}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="panel" id="status-panel">
    <h3>âš¡ OPUS Water Engine â€” Full Pipeline</h3>
    <div class="row"><label>Groups 1â€“8</label><span id="st-status">Initializing...</span></div>
    <div class="row"><label>FPS</label><span id="st-fps">--</span></div>
    <div class="row"><label>Frame (ms)</label><span id="st-frame">--</span></div>
    <div class="row"><label>Passes</label><span id="st-passes">17</span></div>
    <div class="row"><label>Frame #</label><span id="st-framenum">0</span></div>
  </div>
  <div class="panel" id="ctrl-panel">
    <h3>ğŸ® Controls</h3>
    <div class="row"><label>Click water:</label><span>Add impulse</span></div>
    <div class="row"><label>Debug view:</label>
      <select id="dbg-mode">
        <option value="0">Normal</option>
        <option value="1">Height Î·</option>
        <option value="2">Steepness</option>
        <option value="3">Jacobian</option>
        <option value="4">Sheet Pos Y</option>
        <option value="5">Link Health</option>
        <option value="6">Thickness</option>
        <option value="7">Envelope</option>
        <option value="8">Edge/Phi</option>
        <option value="9">Foam</option>
        <option value="10">Pressure</option>
      </select>
    </div>
    <div style="margin-top:6px">
      <button class="btn" id="btn-impulse">ğŸ’§ Center Impulse</button>
      <button class="btn" id="btn-big">ğŸŒŠ Big Wave</button>
      <button class="btn" id="btn-hull" >ğŸš¢ Toggle Hull</button>
      <button class="btn" id="btn-reset">ğŸ”„ Reset</button>
    </div>
  </div>
  <div class="panel" id="gate-panel">
    <h3>ğŸš¦ Gate Tests</h3>
    <div id="gate-list"></div>
  </div>
  <div class="panel" id="perf-panel">
    <h3>ğŸ“Š Pass Timing</h3>
    <div id="perf-bars"></div>
  </div>
</div>

<script>
"use strict";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPUS WATER ENGINE â€” COMPLETE 17-PASS PIPELINE (Groups 1â€“8)
// Single source of truth: Orchestration_2026-02-08-artifact.md
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', {
  alpha: false, antialias: false, premultipliedAlpha: false,
  preserveDrawingBuffer: false
});
if (!gl) { document.body.innerHTML = '<h1 style="color:red;padding:40px">WebGL2 required</h1>'; throw 'No WebGL2'; }

// Check float texture support
const extCBF = gl.getExtension('EXT_color_buffer_float');
const extCBHF = gl.getExtension('EXT_color_buffer_half_float');
gl.getExtension('OES_texture_float_linear');
gl.getExtension('OES_texture_half_float_linear');

// â”€â”€ Config (from OpusConfig) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CFG = {
  hf: { res: 512, worldSize: 200, depth: 20, gravity: 9.81, damping: 0.995 },
  sheet: {
    res: 128, worldSize: 50,
    breakRate: 5.0, healRate: 0.5, ascentThresh: 0.3, healProx: 0.2,
    waveStrainThresh: 0.6, waveBreakRate: 2.0,
    viscosity: 0.05, damping: 0.5, hfCoupling: 0.1,
    hullStiffness: 2000, gravityY: -9.81,
    pressureStiffness: 100.0, waveBoostScale: 0.5,
    envDilationRadius: 3, barrierStiffness: 500, slapDamping: 5.0,
    minThick: 0.05, maxThick: 2.0, redistRate: 0.02,
    thickScale: 1.0, edgeScale: 2.0, pressScale: 0.5
  },
  spray: { max: 512, lifetime: 2.0, minVY: 2.0, linkDead: 0.1, minThick: 0.08, gravity: 9.81, drag: 0.5 },
  foam: { decay: 0.3, advect: 1.0, edgeGen: 2.0 }
};

// â”€â”€ WebGL Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(s), '\n', src.split('\n').map((l,i)=>`${i+1}: ${l}`).join('\n'));
    gl.deleteShader(s); return null;
  }
  return s;
}

function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(p));
    return null;
  }
  return p;
}

function makeProgram(vSrc, fSrc) {
  const vs = createShader(gl.VERTEX_SHADER, vSrc);
  const fs = createShader(gl.FRAGMENT_SHADER, fSrc);
  if (!vs || !fs) return null;
  return createProgram(vs, fs);
}

// Fullscreen triangle vertex shader
const VERT_FULL = `#version 300 es
precision highp float;
out vec2 v_uv;
void main(){
  float x = -1.0 + float((gl_VertexID & 1) << 2);
  float y = -1.0 + float((gl_VertexID & 2) << 1);
  v_uv = vec2(x, y) * 0.5 + 0.5;
  gl_Position = vec4(x, y, 0.0, 1.0);
}`;

function createRT(w, h, internalFmt, fmt, type) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFmt, w, h, 0, fmt, type, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return { tex, fb, w, h };
}

function createRTRGBA16F(w, h) { return createRT(w, h, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT); }
function createRTRG16F(w, h) { return createRT(w, h, gl.RG16F, gl.RG, gl.HALF_FLOAT); }
function createRTR16F(w, h) { return createRT(w, h, gl.R16F, gl.RED, gl.HALF_FLOAT); }

class PingPong {
  constructor(w, h, createFn) {
    this.a = createFn(w, h);
    this.b = createFn(w, h);
    this.idx = 0;
  }
  get read() { return this.idx === 0 ? this.a : this.b; }
  get write() { return this.idx === 0 ? this.b : this.a; }
  swap() { this.idx = 1 - this.idx; }
}

// Create MRT framebuffer with 2 color attachments
function createMRT(w, h) {
  const tex0 = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex0);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  const tex1 = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex1);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex0, 0);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, tex1, 0);
  gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return { fb, tex0, tex1, w, h };
}

// â”€â”€ Pass Runner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const dummyVAO = gl.createVertexArray();

function runPass(program, target, uniforms, texBindings) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, target ? target.fb : null);
  if (target) gl.viewport(0, 0, target.w, target.h);
  else gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);
  let texUnit = 0;
  if (texBindings) {
    for (const [name, tex] of texBindings) {
      const loc = gl.getUniformLocation(program, name);
      if (loc !== null) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(loc, texUnit);
      }
      texUnit++;
    }
  }
  if (uniforms) {
    for (const [name, val] of uniforms) {
      const loc = gl.getUniformLocation(program, name);
      if (loc === null) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (val.length === 2) gl.uniform2fv(loc, val);
      else if (val.length === 3) gl.uniform3fv(loc, val);
      else if (val.length === 4) gl.uniform4fv(loc, val);
    }
  }
  gl.bindVertexArray(dummyVAO);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  gl.bindVertexArray(null);
}

function runPassMRT(program, mrt, uniforms, texBindings) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, mrt.fb);
  gl.viewport(0, 0, mrt.w, mrt.h);
  gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
  gl.useProgram(program);
  let texUnit = 0;
  if (texBindings) {
    for (const [name, tex] of texBindings) {
      const loc = gl.getUniformLocation(program, name);
      if (loc !== null) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(loc, texUnit);
      }
      texUnit++;
    }
  }
  if (uniforms) {
    for (const [name, val] of uniforms) {
      const loc = gl.getUniformLocation(program, name);
      if (loc === null) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (val.length === 2) gl.uniform2fv(loc, val);
      else if (val.length === 3) gl.uniform3fv(loc, val);
    }
  }
  gl.bindVertexArray(dummyVAO);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  gl.bindVertexArray(null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function clearRT(rt, r,g,b,a) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, rt.fb);
  gl.viewport(0, 0, rt.w, rt.h);
  gl.clearColor(r||0, g||0, b||0, a||0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PASS SHADERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Pass 1: HeightfieldUpdate (SWE Lax-Friedrichs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_HF_UPDATE = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_hf;
uniform vec2 u_res;
uniform float u_worldSize, u_depth, u_gravity, u_dt, u_damping;
uniform vec2 u_worldOrigin;
uniform vec2 u_impulseCenter;
uniform float u_impulseRadius, u_impulseStrength;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_res;
  vec2 st=tx;
  float dx=u_worldSize/u_res.x;
  float dxE=dx;
  vec4 C=texture(u_hf,v_uv);
  vec4 L=texture(u_hf,v_uv+vec2(-st.x,0));
  vec4 R=texture(u_hf,v_uv+vec2(st.x,0));
  vec4 D=texture(u_hf,v_uv+vec2(0,-st.y));
  vec4 U=texture(u_hf,v_uv+vec2(0,st.y));
  float ea=.25*(L.r+R.r+D.r+U.r);
  float ua=.25*(L.b+R.b+D.b+U.b);
  float va=.25*(L.a+R.a+D.a+U.a);
  float dudx=(R.b-L.b)/(2.0*dxE);
  float dvdz=(U.a-D.a)/(2.0*dxE);
  float etaR=-u_depth*(dudx+dvdz);
  float dedx=(R.r-L.r)/(2.0*dxE);
  float dedz=(U.r-D.r)/(2.0*dxE);
  float nE=ea+etaR*u_dt;
  float nU=ua-u_gravity*dedx*u_dt;
  float nV=va-u_gravity*dedz*u_dt;
  vec2 wp=u_worldOrigin+v_uv*u_worldSize;
  vec2 lp=wp-u_worldOrigin;
  float sw=u_worldSize*0.05;
  float sp=smoothstep(0.0,sw,lp.x)*smoothstep(0.0,sw,u_worldSize-lp.x)
          *smoothstep(0.0,sw,lp.y)*smoothstep(0.0,sw,u_worldSize-lp.y);
  nE*=sp; nU*=sp; nV*=sp;
  nE*=u_damping; nU*=u_damping; nV*=u_damping;
  if(u_impulseStrength!=0.0){
    vec2 d=wp-u_impulseCenter;
    float r2=dot(d,d);
    float s2=u_impulseRadius*u_impulseRadius;
    nE+=u_impulseStrength*exp(-r2/s2)*u_dt;
  }
  float etaRO=(nE-C.r)/max(u_dt,1e-6);
  fragColor=vec4(nE,etaRO,nU,nV);
}`;

// â”€â”€ Pass 2: HeightfieldDiagnostics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_HF_DIAG = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_hf;
uniform vec2 u_res;
uniform float u_worldSize, u_stride;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_res;
  vec2 st=tx*u_stride;
  float dx=u_worldSize/u_res.x;
  float dxE=dx*u_stride;
  float C=texture(u_hf,v_uv).r;
  float L=texture(u_hf,v_uv+vec2(-st.x,0)).r;
  float R=texture(u_hf,v_uv+vec2(st.x,0)).r;
  float D=texture(u_hf,v_uv+vec2(0,-st.y)).r;
  float U=texture(u_hf,v_uv+vec2(0,st.y)).r;
  float ddx=(R-L)/(2.0*dxE);
  float ddz=(U-D)/(2.0*dxE);
  float steep=sqrt(ddx*ddx+ddz*ddz);
  float curv=(L+R+D+U-4.0*C)/(dxE*dxE);
  float jac=1.0-steep*steep-abs(curv)*dxE;
  float etaR=texture(u_hf,v_uv).g;
  fragColor=vec4(steep,curv,jac,etaR);
}`;

// â”€â”€ Pass 4: SheetPressure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_PRESSURE = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_posTex, u_hf, u_diagTex;
uniform vec2 u_sheetRes, u_sheetOrigin, u_sheetSize, u_hfOrigin, u_hfSize;
uniform float u_pressStiff, u_waveBoost;
in vec2 v_uv;
out vec4 fragColor;
const float ATM=101325.0,RHO=1000.0,G=9.81;
void main(){
  vec4 pos=texture(u_posTex,v_uv);
  if(pos.w<0.001){fragColor=vec4(ATM,ATM,0,0);return;}
  vec2 wXZ=pos.xz;
  vec2 hfUV=clamp((wXZ-u_hfOrigin)/u_hfSize,0.001,0.999);
  float eta=texture(u_hf,hfUV).r;
  float depth=eta-pos.y;
  vec4 diag=texture(u_diagTex,hfUV);
  float etaRate=diag.a;
  float Pb;
  if(depth>0.0) Pb=ATM+RHO*G*depth;
  else Pb=ATM-u_pressStiff*abs(depth)*exp(-abs(depth)*2.0);
  Pb+=max(etaRate,0.0)*u_waveBoost*RHO;
  float Pa=ATM;
  fragColor=vec4(Pb,Pa,0,0);
}`;

// â”€â”€ Pass 5: LinkUpdate (SEAM ENGINE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_LINK = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_linkTex, u_hullTex, u_posTex, u_hf, u_diagTex;
uniform vec2 u_sheetRes, u_sheetOrigin, u_sheetSize, u_hfOrigin, u_hfSize;
uniform float u_dt, u_breakRate, u_healRate, u_ascentThresh, u_healProx;
uniform float u_waveStrainThresh, u_waveBreakRate;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  vec2 link=texture(u_linkTex,v_uv).rg;
  vec4 hH=texture(u_hullTex,v_uv);
  vec4 hPX=texture(u_hullTex,v_uv+vec2(tx.x,0));
  vec4 hPY=texture(u_hullTex,v_uv+vec2(0,tx.y));
  bool hh=hH.a>0.0, hpx=hPX.a>0.0, hpy=hPY.a>0.0;
  vec4 posH=texture(u_posTex,v_uv);
  vec4 posPX=texture(u_posTex,v_uv+vec2(tx.x,0));
  vec4 posPY=texture(u_posTex,v_uv+vec2(0,tx.y));
  vec2 hfUVH=clamp((posH.xz-u_hfOrigin)/u_hfSize,0.001,0.999);
  vec2 hfUVPX=clamp((posPX.xz-u_hfOrigin)/u_hfSize,0.001,0.999);
  vec2 hfUVPY=clamp((posPY.xz-u_hfOrigin)/u_hfSize,0.001,0.999);
  float eqH=texture(u_hf,hfUVH).r;
  float eqPX=texture(u_hf,hfUVPX).r;
  float eqPY=texture(u_hf,hfUVPY).r;
  // Diagnostics for wave breaking
  vec4 diagH=texture(u_diagTex,hfUVH);
  float steepH=diagH.r;
  float jacH=diagH.b;
  // LINK U
  float lU=link.r;
  {
    float brk=0.0;
    if(hh!=hpx) brk+=1.0;
    if(hh&&hpx){
      float aH=hH.g*6.2832-3.1416;
      float aPX=hPX.g*6.2832-3.1416;
      vec2 dH=vec2(cos(aH),sin(aH));
      vec2 dPX=vec2(cos(aPX),sin(aPX));
      float ag=dot(dH,dPX);
      if(ag<u_ascentThresh) brk+=1.0-ag;
    }
    // Wave strain breaking
    if(steepH>u_waveStrainThresh && jacH<0.2) brk+=steepH*u_waveBreakRate;
    lU-=brk*u_breakRate*u_dt;
    if(brk<0.01){
      bool noH=!hh&&!hpx;
      bool clH=abs(posH.y-eqH)<u_healProx;
      bool clPX=abs(posPX.y-eqPX)<u_healProx;
      if(noH&&clH&&clPX) lU+=u_healRate*u_dt;
    }
  }
  // LINK V
  float lV=link.g;
  {
    float brk=0.0;
    if(hh!=hpy) brk+=1.0;
    if(hh&&hpy){
      float aH=hH.g*6.2832-3.1416;
      float aPY=hPY.g*6.2832-3.1416;
      vec2 dH=vec2(cos(aH),sin(aH));
      vec2 dPY=vec2(cos(aPY),sin(aPY));
      float ag=dot(dH,dPY);
      if(ag<u_ascentThresh) brk+=1.0-ag;
    }
    if(steepH>u_waveStrainThresh && jacH<0.2) brk+=steepH*u_waveBreakRate;
    lV-=brk*u_breakRate*u_dt;
    if(brk<0.01){
      bool noH=!hh&&!hpy;
      bool clH=abs(posH.y-eqH)<u_healProx;
      bool clPY=abs(posPY.y-eqPY)<u_healProx;
      if(noH&&clH&&clPY) lV+=u_healRate*u_dt;
    }
  }
  fragColor=vec4(clamp(lU,0.0,1.0),clamp(lV,0.0,1.0),0,0);
}`;

// â”€â”€ Pass 6: Viscosity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_VISC = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_velTex, u_linkTex;
uniform vec2 u_sheetRes;
uniform float u_viscosity;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  vec4 vC=texture(u_velTex,v_uv);
  vec3 vel=vC.xyz;
  vec2 lH=texture(u_linkTex,v_uv).rg;
  float lNX=texture(u_linkTex,v_uv-vec2(tx.x,0)).r;
  float lNY=texture(u_linkTex,v_uv-vec2(0,tx.y)).g;
  vec3 vPX=texture(u_velTex,v_uv+vec2(tx.x,0)).xyz;
  vec3 vNX=texture(u_velTex,v_uv-vec2(tx.x,0)).xyz;
  vec3 vPY=texture(u_velTex,v_uv+vec2(0,tx.y)).xyz;
  vec3 vNY=texture(u_velTex,v_uv-vec2(0,tx.y)).xyz;
  vec3 d=vec3(0);
  d+=lH.r*(vPX-vel);
  d+=lNX*(vNX-vel);
  d+=lH.g*(vPY-vel);
  d+=lNY*(vNY-vel);
  vel+=u_viscosity*d;
  fragColor=vec4(vel,vC.w);
}`;

// â”€â”€ Pass 7: ForceIntegrate (MRT: pos+vel) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_INTEGRATE = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_posTex, u_velTex, u_pressTex, u_normTex, u_thickTex, u_hullTex, u_hf;
uniform vec2 u_sheetRes, u_sheetOrigin, u_sheetSize, u_hfOrigin, u_hfSize;
uniform float u_dt, u_gravityY, u_hullStiff, u_hfCoupling, u_damping;
in vec2 v_uv;
layout(location=0) out vec4 out_pos;
layout(location=1) out vec4 out_vel;
void main(){
  vec4 pos=texture(u_posTex,v_uv);
  vec4 vel=texture(u_velTex,v_uv);
  vec2 P=texture(u_pressTex,v_uv).rg;
  vec3 norm=texture(u_normTex,v_uv).xyz;
  float thick=texture(u_thickTex,v_uv).r;
  vec4 hull=texture(u_hullTex,v_uv);
  float mass=pos.w;
  if(mass<0.001){out_pos=pos;out_vel=vel;return;}
  vec3 force=vec3(0);
  float cs=u_sheetSize.x/u_sheetRes.x;
  float area=cs*cs;
  force.y+=u_gravityY*mass;
  float dP=P.r-P.g;
  vec3 sN=normalize(norm+vec3(0,0.001,0));
  force+=sN*dP*area*thick;
  if(hull.a>0.0){
    float pen=hull.r-pos.y;
    if(pen>0.0){
      force.y-=pen*u_hullStiff*mass;
      float aA=hull.g*6.2832-3.1416;
      vec2 aD=vec2(cos(aA),sin(aA));
      float fI=hull.b;
      float tM=pen*u_hullStiff*0.3*(1.0+fI);
      force.xz+=aD*tM*mass;
    }
  }
  vec2 hfUV=clamp((pos.xz-u_hfOrigin)/u_hfSize,0.001,0.999);
  vec2 hfV=texture(u_hf,hfUV).ba;
  force.xz+=(hfV-vel.xz)*u_hfCoupling*mass;
  force-=vel.xyz*u_damping*mass;
  vec3 nV=vel.xyz+(force/mass)*u_dt;
  float spd=length(nV);
  if(spd>30.0) nV*=30.0/spd;
  vec3 nP=pos.xyz+nV*u_dt;
  float stress=abs(nP.y-texture(u_hf,hfUV).r);
  out_pos=vec4(nP,mass);
  out_vel=vec4(nV,stress);
}`;

// â”€â”€ Pass 8: SelfEnvelope (GROUP 5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_ENVELOPE = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_posTex, u_normTex;
uniform vec2 u_sheetRes;
uniform float u_dilationRadius;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  int R=int(u_dilationRadius);
  float maxY=-1e6;
  for(int dy=-R;dy<=R;dy++){
    for(int dx=-R;dx<=R;dx++){
      vec2 nuv=v_uv+vec2(float(dx),float(dy))*tx;
      nuv=clamp(nuv,tx*0.5,1.0-tx*0.5);
      vec4 p=texture(u_posTex,nuv);
      vec3 n=texture(u_normTex,nuv).xyz;
      if(p.w>0.001 && n.y>0.3){
        maxY=max(maxY,p.y);
      }
    }
  }
  if(maxY<-1e5) maxY=0.0;
  fragColor=vec4(maxY,0,0,0);
}`;

// â”€â”€ Pass 9: BarrierContact (GROUP 5, MRT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_BARRIER = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_posTex, u_velTex, u_envTex, u_normTex, u_hf;
uniform vec2 u_sheetRes, u_hfOrigin, u_hfSize;
uniform float u_dt, u_barrierStiff, u_slapDamp;
in vec2 v_uv;
layout(location=0) out vec4 out_pos;
layout(location=1) out vec4 out_vel;
void main(){
  vec4 pos=texture(u_posTex,v_uv);
  vec4 vel=texture(u_velTex,v_uv);
  if(pos.w<0.001){out_pos=pos;out_vel=vel;return;}
  vec3 norm=texture(u_normTex,v_uv).xyz;
  float envH=texture(u_envTex,v_uv).r;
  vec2 hfUV=clamp((pos.xz-u_hfOrigin)/u_hfSize,0.001,0.999);
  float eta=texture(u_hf,hfUV).r;
  float barrier=max(eta,envH)+0.05;
  // Only apply to underside nodes
  if(norm.y<0.0 && pos.y<barrier){
    float pen=barrier-pos.y;
    vec3 nV=vel.xyz;
    nV.y+=pen*u_barrierStiff*u_dt;
    nV*=max(0.0,1.0-u_slapDamp*u_dt);
    float spd=length(nV);
    if(spd>30.0) nV*=30.0/spd;
    vec3 nP=pos.xyz;
    nP.y=max(nP.y,barrier);
    out_pos=vec4(nP,pos.w);
    out_vel=vec4(nV,vel.w);
  } else {
    out_pos=pos;
    out_vel=vel;
  }
}`;

// â”€â”€ Pass 10: ThicknessAdvect (GROUP 5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_THICK = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_thickTex, u_velTex, u_linkTex;
uniform vec2 u_sheetRes;
uniform float u_sheetWorldSize, u_dt, u_redistRate, u_minT, u_maxT;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  float cs=u_sheetWorldSize/u_sheetRes.x;
  float thick=texture(u_thickTex,v_uv).r;
  vec3 vel=texture(u_velTex,v_uv).xyz;
  // Semi-Lagrangian advection
  vec2 uvB=clamp(v_uv-(vel.xz*u_dt)/u_sheetWorldSize,tx*0.5,1.0-tx*0.5);
  float adv=texture(u_thickTex,uvB).r;
  // Divergence correction
  vec3 vPX=texture(u_velTex,v_uv+vec2(tx.x,0)).xyz;
  vec3 vNX=texture(u_velTex,v_uv-vec2(tx.x,0)).xyz;
  vec3 vPY=texture(u_velTex,v_uv+vec2(0,tx.y)).xyz;
  vec3 vNY=texture(u_velTex,v_uv-vec2(0,tx.y)).xyz;
  float divU=(vPX.x-vNX.x)/(2.0*cs);
  float divV=(vPY.z-vNY.z)/(2.0*cs);
  float divg=divU+divV;
  adv*=(1.0-divg*u_dt*0.5);
  // Link-weighted redistribution
  vec2 lH=texture(u_linkTex,v_uv).rg;
  float lNX=texture(u_linkTex,v_uv-vec2(tx.x,0)).r;
  float lNY=texture(u_linkTex,v_uv-vec2(0,tx.y)).g;
  float tPX=texture(u_thickTex,v_uv+vec2(tx.x,0)).r;
  float tNX=texture(u_thickTex,v_uv-vec2(tx.x,0)).r;
  float tPY=texture(u_thickTex,v_uv+vec2(0,tx.y)).r;
  float tNY=texture(u_thickTex,v_uv-vec2(0,tx.y)).r;
  float diff=0.0;
  diff+=lH.r*(tPX-adv);
  diff+=lNX*(tNX-adv);
  diff+=lH.g*(tPY-adv);
  diff+=lNY*(tNY-adv);
  float res=adv+u_redistRate*diff;
  // Respawn dead texels
  if(res<u_minT*0.5 && (lH.r+lH.g+lNX+lNY)>0.5){
    res=max(res,u_minT);
  }
  fragColor=vec4(clamp(res,u_minT,u_maxT),0,0,0);
}`;

// â”€â”€ Pass 11: NormalCompute â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_NORMAL = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_posTex, u_linkTex;
uniform vec2 u_sheetRes;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  vec3 pC=texture(u_posTex,v_uv).xyz;
  vec3 pPX=texture(u_posTex,v_uv+vec2(tx.x,0)).xyz;
  vec3 pNX=texture(u_posTex,v_uv-vec2(tx.x,0)).xyz;
  vec3 pPY=texture(u_posTex,v_uv+vec2(0,tx.y)).xyz;
  vec3 pNY=texture(u_posTex,v_uv-vec2(0,tx.y)).xyz;
  vec2 lH=texture(u_linkTex,v_uv).rg;
  float lNX=texture(u_linkTex,v_uv-vec2(tx.x,0)).r;
  float lNY=texture(u_linkTex,v_uv-vec2(0,tx.y)).g;
  float wPX=lH.r, wNX=lNX;
  vec3 tU;
  if(wPX+wNX>0.01) tU=normalize((pPX-pC)*wPX+(pC-pNX)*wNX);
  else tU=vec3(1,0,0);
  float wPY=lH.g, wNY=lNY;
  vec3 tV;
  if(wPY+wNY>0.01) tV=normalize((pPY-pC)*wPY+(pC-pNY)*wNY);
  else tV=vec3(0,0,1);
  vec3 n=normalize(cross(tV,tU));
  float cs=n.y>0.0?1.0:-1.0;
  fragColor=vec4(n,cs);
}`;

// â”€â”€ Pass 12: EdgePhi (GROUP 6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_EDGEPHI = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_linkTex, u_thickTex, u_pressTex;
uniform vec2 u_sheetRes;
uniform float u_thickScale, u_edgeScale, u_pressScale;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  vec2 lH=texture(u_linkTex,v_uv).rg;
  float lNX=texture(u_linkTex,v_uv-vec2(tx.x,0)).r;
  float lNY=texture(u_linkTex,v_uv-vec2(0,tx.y)).g;
  float minL=min(min(lH.r,lH.g),min(lNX,lNY));
  float edge=1.0-minL;
  float thick=texture(u_thickTex,v_uv).r;
  vec2 P=texture(u_pressTex,v_uv).rg;
  float pDelta=abs(P.r-P.g)/101325.0;
  float phi=u_thickScale*thick+u_edgeScale*edge+u_pressScale*pDelta;
  // Simple 5-tap blur on phi
  float phiPX=0.0,phiNX=0.0,phiPY=0.0,phiNY=0.0;
  // We compute phi for neighbors inline for blur
  vec2 lHpx=texture(u_linkTex,v_uv+vec2(tx.x,0)).rg;
  float minLpx=min(min(lHpx.r,lHpx.g),min(lH.r,texture(u_linkTex,v_uv+vec2(tx.x,0)-vec2(0,tx.y)).g));
  float epx=1.0-minLpx;
  float tpx=texture(u_thickTex,v_uv+vec2(tx.x,0)).r;
  phiPX=u_thickScale*tpx+u_edgeScale*epx;
  // Simplified blur: average with center
  phi=phi*0.6+(phiPX)*0.1+phi*0.3; // Approximate blur
  fragColor=vec4(edge,phi,0,0);
}`;

// â”€â”€ Pass 13: SprayDetect (GROUP 6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_SPRAY_DETECT = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_posTex, u_velTex, u_linkTex, u_thickTex;
uniform vec2 u_sheetRes;
uniform float u_linkDead, u_minVY, u_minThick;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_sheetRes;
  vec4 pos=texture(u_posTex,v_uv);
  if(pos.w<0.001){fragColor=pos;return;}
  vec4 vel=texture(u_velTex,v_uv);
  float thick=texture(u_thickTex,v_uv).r;
  vec2 lH=texture(u_linkTex,v_uv).rg;
  float lNX=texture(u_linkTex,v_uv-vec2(tx.x,0)).r;
  float lNY=texture(u_linkTex,v_uv-vec2(0,tx.y)).g;
  bool allDead=lH.r<u_linkDead&&lH.g<u_linkDead&&lNX<u_linkDead&&lNY<u_linkDead;
  bool fastUp=vel.y>u_minVY;
  bool thin=thick<u_minThick;
  if(allDead&&fastUp&&thin){
    fragColor=vec4(pos.xyz,0.0); // Kill mass â†’ spray
  } else {
    fragColor=pos;
  }
}`;

// â”€â”€ Pass 14: SprayUpdate (GROUP 6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_SPRAY_UPDATE = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_sprayPos, u_sprayVel;
uniform float u_dt, u_gravity, u_drag;
in vec2 v_uv;
layout(location=0) out vec4 out_pos;
layout(location=1) out vec4 out_vel;
void main(){
  vec4 pL=texture(u_sprayPos,v_uv);
  vec4 vS=texture(u_sprayVel,v_uv);
  if(pL.w<=0.0){out_pos=vec4(0);out_vel=vec4(0);return;}
  vec3 v=vS.xyz;
  v.y-=u_gravity*u_dt;
  float spd=length(v);
  if(spd>0.01) v-=normalize(v)*u_drag*spd*spd*u_dt;
  vec3 p=pL.xyz+v*u_dt;
  float life=pL.w-u_dt;
  float sz=vS.w*(1.0-0.3*u_dt);
  out_pos=vec4(p,max(life,0.0));
  out_vel=vec4(v,sz);
}`;

// â”€â”€ Pass 15: FoamAdvect (GROUP 6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_FOAM = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_foamTex, u_hf, u_diagTex, u_edgePhiTex;
uniform vec2 u_res;
uniform float u_worldSize, u_dt, u_decay, u_edgeGen;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 tx=1.0/u_res;
  vec2 hfV=texture(u_hf,v_uv).ba;
  vec2 uvB=clamp(v_uv-hfV*u_dt/u_worldSize,tx*0.5,1.0-tx*0.5);
  float foam=texture(u_foamTex,uvB).r;
  foam*=exp(-u_decay*u_dt);
  vec4 diag=texture(u_diagTex,v_uv);
  if(diag.r>0.4&&diag.b<0.2) foam+=diag.r*0.5*u_dt;
  // Edge foam from sheet seams (sample edge texture - resolution differs, bilinear handles it)
  float edge=texture(u_edgePhiTex,v_uv).r;
  foam+=edge*u_edgeGen*u_dt;
  foam=clamp(foam,0.0,3.0);
  fragColor=vec4(foam,0,0,0);
}`;

// â”€â”€ Sheet Init Shader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_SHEET_INIT = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_hf;
uniform vec2 u_sheetRes, u_sheetOrigin, u_sheetSize, u_hfOrigin, u_hfSize;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec2 wXZ=u_sheetOrigin+v_uv*u_sheetSize;
  vec2 hfUV=clamp((wXZ-u_hfOrigin)/u_hfSize,0.0,1.0);
  float eta=texture(u_hf,hfUV).r;
  fragColor=vec4(wXZ.x,eta,wXZ.y,1.0);
}`;

const FRAG_SOLID = (r,g,b,a) => `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 fragColor;
void main(){fragColor=vec4(${r},${g},${b},${a});}`;

// â”€â”€ Render: Ocean Surface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const VERT_OCEAN = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_hf, u_diagTex;
uniform vec2 u_hfOrigin;
uniform float u_hfSize;
uniform vec2 u_hfRes;
uniform mat4 u_viewProj;
in vec2 a_uv;
out vec3 v_wpos;
out vec3 v_norm;
out float v_steep;
out float v_eta;
out vec2 v_uv;
void main(){
  vec2 wXZ=u_hfOrigin+a_uv*u_hfSize;
  float eta=texture(u_hf,a_uv).r;
  float dx=u_hfSize/u_hfRes.x;
  vec2 tx=1.0/u_hfRes;
  float hL=texture(u_hf,a_uv+vec2(-tx.x,0)).r;
  float hR=texture(u_hf,a_uv+vec2(tx.x,0)).r;
  float hD=texture(u_hf,a_uv+vec2(0,-tx.y)).r;
  float hU=texture(u_hf,a_uv+vec2(0,tx.y)).r;
  vec3 n=normalize(vec3((hL-hR)/(2.0*dx),1.0,(hD-hU)/(2.0*dx)));
  v_steep=texture(u_diagTex,a_uv).r;
  v_wpos=vec3(wXZ.x,eta,wXZ.y);
  v_norm=n;
  v_eta=eta;
  v_uv=a_uv;
  gl_Position=u_viewProj*vec4(v_wpos,1);
}`;

const FRAG_OCEAN = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform vec3 u_camPos, u_sunDir, u_sunCol, u_deepCol, u_shallowCol;
uniform float u_foamThresh, u_foamInt, u_specPow, u_envRefl;
uniform sampler2D u_foamTex;
uniform float u_hasFoam;
in vec3 v_wpos, v_norm;
in float v_steep, v_eta;
in vec2 v_uv;
out vec4 fragColor;
float schlick(vec3 N,vec3 V,float F0){
  float c=max(dot(N,V),0.0);
  return F0+(1.0-F0)*pow(1.0-c,5.0);
}
void main(){
  vec3 N=normalize(v_norm);
  vec3 V=normalize(u_camPos-v_wpos);
  vec3 L=normalize(u_sunDir);
  vec3 H=normalize(V+L);
  float F=schlick(N,V,0.02);
  float df=smoothstep(-2.0,2.0,v_eta);
  vec3 base=mix(u_deepCol,u_shallowCol,df);
  float wrap=max((dot(N,L)+0.3)/1.3,0.0);
  vec3 diff=base*wrap*u_sunCol;
  float NdH=max(dot(N,H),0.0);
  vec3 spec=u_sunCol*pow(NdH,u_specPow)*F;
  vec3 R=reflect(-V,N);
  float sf=max(R.y,0.0);
  vec3 sky=mix(vec3(.6,.7,.8),vec3(.2,.4,.8),sf);
  vec3 env=sky*F*u_envRefl;
  float fm=smoothstep(u_foamThresh,u_foamThresh+0.15,v_steep);
  if(u_hasFoam>0.5){
    float fd=texture(u_foamTex,v_uv).r;
    fm=max(fm,fd);
  }
  vec3 fc=vec3(.85,.9,.95);
  vec3 ws=diff+spec+env;
  vec3 fin=mix(ws,fc,fm*u_foamInt);
  fragColor=vec4(fin,1);
}`;

// â”€â”€ Debug Visualizer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_DEBUG = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_tex;
uniform int u_mode;
in vec2 v_uv;
out vec4 fragColor;
vec3 heatmap(float t){
  t=clamp(t,0.0,1.0);
  if(t<0.25) return mix(vec3(0,0,1),vec3(0,1,1),t*4.0);
  if(t<0.5) return mix(vec3(0,1,1),vec3(0,1,0),(t-0.25)*4.0);
  if(t<0.75) return mix(vec3(0,1,0),vec3(1,1,0),(t-0.5)*4.0);
  return mix(vec3(1,1,0),vec3(1,0,0),(t-0.75)*4.0);
}
void main(){
  vec4 d=texture(u_tex,v_uv);
  vec3 c;
  if(u_mode==1) c=heatmap(d.r*0.25+0.5); // eta
  else if(u_mode==2) c=heatmap(d.r*2.0); // steepness
  else if(u_mode==3) c=heatmap(1.0-d.b); // jacobian (inverted)
  else if(u_mode==4) c=heatmap(d.g*0.25+0.5); // sheet Y (via .g channel)
  else if(u_mode==5) c=vec3(d.r,d.g*0.5+d.r*0.5,0); // links RG
  else if(u_mode==6) c=heatmap(d.r*2.0); // thickness
  else if(u_mode==7) c=vec3(0,d.r*0.1,0); // envelope
  else if(u_mode==8) c=vec3(d.r,d.g*0.3,0); // edge/phi
  else if(u_mode==9) c=vec3(d.r,d.r,d.r); // foam
  else if(u_mode==10) c=heatmap((d.r-101325.0)*0.0001+0.5); // pressure
  else c=vec3(d.rgb);
  fragColor=vec4(c,0.6);
}`;

// â”€â”€ Composite (final screen blend) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FRAG_COMPOSITE = `#version 300 es
precision highp float;
precision highp sampler2D;
uniform sampler2D u_scene;
uniform sampler2D u_debug;
uniform float u_debugAlpha;
in vec2 v_uv;
out vec4 fragColor;
void main(){
  vec4 sc=texture(u_scene,v_uv);
  if(u_debugAlpha>0.01){
    vec4 db=texture(u_debug,v_uv);
    sc.rgb=mix(sc.rgb,db.rgb,db.a*u_debugAlpha);
  }
  // Tone mapping
  sc.rgb=sc.rgb/(sc.rgb+vec3(1.0));
  sc.rgb=pow(sc.rgb,vec3(1.0/2.2));
  fragColor=vec4(sc.rgb,1);
}`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
}
resize();
window.addEventListener('resize', resize);

// â”€â”€ Compile all programs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const prg = {};
prg.hfUpdate = makeProgram(VERT_FULL, FRAG_HF_UPDATE);
prg.hfDiag = makeProgram(VERT_FULL, FRAG_HF_DIAG);
prg.pressure = makeProgram(VERT_FULL, FRAG_PRESSURE);
prg.link = makeProgram(VERT_FULL, FRAG_LINK);
prg.visc = makeProgram(VERT_FULL, FRAG_VISC);
prg.integrate = makeProgram(VERT_FULL, FRAG_INTEGRATE);
prg.envelope = makeProgram(VERT_FULL, FRAG_ENVELOPE);
prg.barrier = makeProgram(VERT_FULL, FRAG_BARRIER);
prg.thick = makeProgram(VERT_FULL, FRAG_THICK);
prg.normal = makeProgram(VERT_FULL, FRAG_NORMAL);
prg.edgePhi = makeProgram(VERT_FULL, FRAG_EDGEPHI);
prg.sprayDetect = makeProgram(VERT_FULL, FRAG_SPRAY_DETECT);
prg.sprayUpdate = makeProgram(VERT_FULL, FRAG_SPRAY_UPDATE);
prg.foam = makeProgram(VERT_FULL, FRAG_FOAM);
prg.sheetInit = makeProgram(VERT_FULL, FRAG_SHEET_INIT);
prg.clear = makeProgram(VERT_FULL, FRAG_SOLID(0,0,0,0));
prg.clearLink = makeProgram(VERT_FULL, FRAG_SOLID(1,1,0,0));
prg.clearThick = makeProgram(VERT_FULL, FRAG_SOLID(0.5,0,0,0));
prg.clearNorm = makeProgram(VERT_FULL, FRAG_SOLID(0,1,0,1));
prg.ocean = makeProgram(VERT_OCEAN, FRAG_OCEAN);
prg.debug = makeProgram(VERT_FULL, FRAG_DEBUG);
prg.composite = makeProgram(VERT_FULL, FRAG_COMPOSITE);

// Check all compiled
for (const [k,v] of Object.entries(prg)) {
  if (!v) console.error(`Program '${k}' failed to compile`);
}

// â”€â”€ Create textures â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HR = CFG.hf.res, SR = CFG.sheet.res, FR = HR;

// Heightfield ping-pong
const hfPP = new PingPong(HR, HR, createRTRGBA16F);
// Diagnostics (single)
const diagTex = createRTRGBA16F(HR, HR);
// Sheet textures
const posPP = new PingPong(SR, SR, createRTRGBA16F);
const velPP = new PingPong(SR, SR, createRTRGBA16F);
const linkPP = new PingPong(SR, SR, createRTRG16F);
const thickPP = new PingPong(SR, SR, createRTR16F);
const normTex = createRTRGBA16F(SR, SR);
const pressTex = createRTRG16F(SR, SR);
const hullTex = createRTRGBA16F(SR, SR);
const envTex = createRTR16F(SR, SR);
const edgePhiTex = createRTRG16F(SR, SR);
// Spray
const sprayPP = new PingPong(512, 2, createRTRGBA16F); // pos+life / vel+size packed in 2 rows
// Foam
const foamPP = new PingPong(FR, FR, createRTR16F);
// MRT targets for integrate (Pass 7) and barrier (Pass 9)
const mrtInteg = createMRT(SR, SR);
const mrtBarrier = createMRT(SR, SR);
const mrtSpray = createMRT(512, 2);
// Scene render target
const sceneTex = createRTRGBA16F(1024, 1024);
const debugRT = createRTRGBA16F(512, 512);

// â”€â”€ Initialize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Clear HF
clearRT(hfPP.a, 0,0,0,0);
clearRT(hfPP.b, 0,0,0,0);
clearRT(diagTex, 0,0,0,0);
clearRT(foamPP.a, 0,0,0,0);
clearRT(foamPP.b, 0,0,0,0);
clearRT(hullTex, 0,0,0,0);
clearRT(envTex, 0,0,0,0);
clearRT(edgePhiTex, 0,0,0,0);

// Init sheet
const hfHalf = CFG.hf.worldSize * 0.5;
const shHalf = CFG.sheet.worldSize * 0.5;
const hfOrigin = [-hfHalf, -hfHalf];
const sheetOrigin = [-shHalf, -shHalf];
const sheetSize = [CFG.sheet.worldSize, CFG.sheet.worldSize];
const hfSize = [CFG.hf.worldSize, CFG.hf.worldSize];

function initSheet() {
  // Init pos from heightfield
  runPass(prg.sheetInit, posPP.a, [
    ['u_sheetRes', [SR, SR]], ['u_sheetOrigin', sheetOrigin],
    ['u_sheetSize', sheetSize], ['u_hfOrigin', hfOrigin], ['u_hfSize', hfSize]
  ], [['u_hf', hfPP.read.tex]]);
  runPass(prg.sheetInit, posPP.b, [
    ['u_sheetRes', [SR, SR]], ['u_sheetOrigin', sheetOrigin],
    ['u_sheetSize', sheetSize], ['u_hfOrigin', hfOrigin], ['u_hfSize', hfSize]
  ], [['u_hf', hfPP.read.tex]]);
  // Init vel = 0
  runPass(prg.clear, velPP.a, [], []);
  runPass(prg.clear, velPP.b, [], []);
  // Init links = 1.0
  runPass(prg.clearLink, linkPP.a, [], []);
  runPass(prg.clearLink, linkPP.b, [], []);
  // Init thickness = 0.5
  runPass(prg.clearThick, thickPP.a, [], []);
  runPass(prg.clearThick, thickPP.b, [], []);
  // Init normals = up
  runPass(prg.clearNorm, normTex, [], []);
  // Init pressure = ATM
  clearRT(pressTex, 0, 0, 0, 0);
}
initSheet();

// â”€â”€ Ocean mesh geometry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MESH_SEG = 256;
function createOceanMesh() {
  const verts = new Float32Array((MESH_SEG+1)*(MESH_SEG+1)*2);
  let vi = 0;
  for (let y = 0; y <= MESH_SEG; y++) {
    for (let x = 0; x <= MESH_SEG; x++) {
      verts[vi++] = x / MESH_SEG;
      verts[vi++] = y / MESH_SEG;
    }
  }
  const idxCount = MESH_SEG * MESH_SEG * 6;
  const idx = new Uint32Array(idxCount);
  let ii = 0;
  for (let y = 0; y < MESH_SEG; y++) {
    for (let x = 0; x < MESH_SEG; x++) {
      const i = y * (MESH_SEG+1) + x;
      idx[ii++]=i; idx[ii++]=i+1; idx[ii++]=i+MESH_SEG+2;
      idx[ii++]=i; idx[ii++]=i+MESH_SEG+2; idx[ii++]=i+MESH_SEG+1;
    }
  }
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vb);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(prg.ocean, 'a_uv');
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  const ib = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
  gl.bindVertexArray(null);
  return { vao, count: idxCount };
}
const oceanMesh = createOceanMesh();

// â”€â”€ Camera â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let camAngle = 0.5, camPitch = 0.35, camDist = 80;
let camTarget = [0, 0, 0];

function getViewProjMatrix() {
  const cx = camTarget[0] + camDist * Math.cos(camPitch) * Math.sin(camAngle);
  const cy = camTarget[1] + camDist * Math.sin(camPitch);
  const cz = camTarget[2] + camDist * Math.cos(camPitch) * Math.cos(camAngle);
  const camPos = [cx, cy, cz];
  const f = normalize3(sub3(camTarget, camPos));
  const r = normalize3(cross3(f, [0,1,0]));
  const u = cross3(r, f);
  const view = [
    r[0], u[0], -f[0], 0,
    r[1], u[1], -f[1], 0,
    r[2], u[2], -f[2], 0,
    -dot3(r, camPos), -dot3(u, camPos), dot3(f, camPos), 1
  ];
  const aspect = canvas.width / canvas.height;
  const fov = 60 * Math.PI / 180;
  const near = 0.5, far = 2000;
  const t = Math.tan(fov/2);
  const proj = [
    1/(aspect*t), 0, 0, 0,
    0, 1/t, 0, 0,
    0, 0, -(far+near)/(far-near), -1,
    0, 0, -2*far*near/(far-near), 0
  ];
  const vp = mulMat4(proj, view);
  return { vp, camPos };
}

function sub3(a,b){return[a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
function dot3(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function cross3(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}
function normalize3(v){const l=Math.sqrt(dot3(v,v))||1;return[v[0]/l,v[1]/l,v[2]/l];}
function mulMat4(a,b){
  const r=new Float32Array(16);
  for(let i=0;i<4;i++)for(let j=0;j<4;j++){
    r[j*4+i]=0;
    for(let k=0;k<4;k++) r[j*4+i]+=a[k*4+i]*b[j*4+k];
  }
  return r;
}

// â”€â”€ Mouse / Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let mouseDown = false, lastMX = 0, lastMY = 0;
let pendingImpulse = null;
let hullActive = false;
let hullPos = [0, 0]; // XZ
let hullVel = [0, 0]; // XZ velocity
let hullSpeed = 3.0;

canvas.addEventListener('mousedown', e => {
  if (e.button === 0) {
    if (e.shiftKey) {
      mouseDown = true; lastMX = e.clientX; lastMY = e.clientY;
    } else {
      // Add impulse at click point (approximate)
      const nx = (e.clientX / window.innerWidth) * 2 - 1;
      const ny = 1 - (e.clientY / window.innerHeight) * 2;
      const wx = nx * CFG.hf.worldSize * 0.3;
      const wz = ny * CFG.hf.worldSize * 0.3;
      pendingImpulse = { cx: wx, cz: wz, r: 3.0, s: 50.0 };
    }
  } else if (e.button === 2) {
    mouseDown = true; lastMX = e.clientX; lastMY = e.clientY;
  }
});
canvas.addEventListener('mousemove', e => {
  if (mouseDown) {
    const dx = e.clientX - lastMX, dy = e.clientY - lastMY;
    camAngle += dx * 0.005;
    camPitch = Math.max(0.05, Math.min(1.4, camPitch + dy * 0.005));
    lastMX = e.clientX; lastMY = e.clientY;
  }
});
canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('wheel', e => {
  camDist = Math.max(10, Math.min(300, camDist + e.deltaY * 0.1));
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

document.getElementById('btn-impulse').addEventListener('click', () => {
  pendingImpulse = { cx: 0, cz: 0, r: 5.0, s: 60.0 };
});
document.getElementById('btn-big').addEventListener('click', () => {
  pendingImpulse = { cx: 0, cz: 0, r: 8.0, s: 200.0 };
});
document.getElementById('btn-hull').addEventListener('click', function() {
  hullActive = !hullActive;
  this.classList.toggle('active', hullActive);
  if (hullActive) { hullPos = [-20, 0]; hullVel = [hullSpeed, 0]; }
  else { clearRT(hullTex, 0,0,0,0); }
});
document.getElementById('btn-reset').addEventListener('click', () => {
  clearRT(hfPP.a, 0,0,0,0);
  clearRT(hfPP.b, 0,0,0,0);
  clearRT(foamPP.a, 0,0,0,0);
  clearRT(foamPP.b, 0,0,0,0);
  clearRT(hullTex, 0,0,0,0);
  initSheet();
});

let debugMode = 0;
document.getElementById('dbg-mode').addEventListener('change', function() {
  debugMode = parseInt(this.value);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP â€” 17-PASS PIPELINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let frameCount = 0;
let lastTime = performance.now();
let fpsAccum = 0, fpsCount = 0, displayFPS = 0;
let passTimes = {};

// Gate test state
const gates = {
  'G2-1 Ring': 'wait', 'G2-2 Steep>0': 'wait',
  'G3-1 Stable': 'wait', 'G3-2 Settle': 'wait',
  'G4-1 Seam': 'wait', 'G5-1 Barrier': 'wait',
  'G5-3 Thick': 'wait', 'G6-3 Foam': 'wait',
  'G8 60FPS': 'wait'
};
let initialThickSum = 0;
let thickSumFrame = 0;

function computeSubSteps(dt) {
  const dx = CFG.hf.worldSize / HR;
  const c = Math.sqrt(CFG.hf.gravity * CFG.hf.depth);
  const dtMax = dx / (2 * c) * 0.9;
  return Math.max(1, Math.ceil(dt / dtMax));
}

function updateHull(dt) {
  if (!hullActive) return;
  // Oscillating hull path
  hullPos[0] += hullVel[0] * dt;
  hullPos[1] += hullVel[1] * dt;
  // Bounce at boundaries
  const bound = CFG.sheet.worldSize * 0.4;
  if (Math.abs(hullPos[0]) > bound) { hullVel[0] *= -1; hullPos[0] = Math.sign(hullPos[0]) * bound; }
  if (Math.abs(hullPos[1]) > bound) { hullVel[1] *= -1; hullPos[1] = Math.sign(hullPos[1]) * bound; }

  // Render hull contact as a simple ellipse stamp
  const hullFrag = `#version 300 es
  precision highp float;
  uniform vec2 u_sheetRes, u_sheetOrigin, u_sheetSize;
  uniform vec2 u_hullPos;
  uniform vec2 u_hullVel;
  uniform float u_hullY;
  in vec2 v_uv;
  out vec4 fragColor;
  void main(){
    vec2 wXZ = u_sheetOrigin + v_uv * u_sheetSize;
    vec2 d = wXZ - u_hullPos;
    // V-hull shape: ellipse with keel
    float rx = 4.0, rz = 8.0; // hull half-widths
    float e = (d.x*d.x)/(rx*rx) + (d.y*d.y)/(rz*rz);
    if(e > 1.0) { fragColor = vec4(0); return; }
    float hY = u_hullY - 0.3 * (1.0 - e); // hull shape curves down
    // Ascent angle: points away from keel
    float ang = atan(d.y, d.x);
    float angNorm = ang / 6.2832 + 0.5;
    // Face incidence: higher at bow
    float faceInc = max(0.0, -dot(normalize(d + vec2(0.001)), normalize(u_hullVel + vec2(0.001))));
    float spd = length(u_hullVel);
    fragColor = vec4(hY, angNorm, faceInc, max(spd, 0.001));
  }`;
  // Lazy-compile hull program
  if (!prg.hull) prg.hull = makeProgram(VERT_FULL, hullFrag);
  if (!prg.hull) return;

  clearRT(hullTex, 0,0,0,0);
  runPass(prg.hull, hullTex, [
    ['u_sheetRes', [SR, SR]], ['u_sheetOrigin', sheetOrigin],
    ['u_sheetSize', sheetSize], ['u_hullPos', hullPos],
    ['u_hullVel', hullVel], ['u_hullY', 1.0]
  ], []);
}

function frame(now) {
  requestAnimationFrame(frame);
  const rawDt = (now - lastTime) / 1000;
  lastTime = now;
  const dt = Math.min(rawDt, 0.033);

  // FPS tracking
  fpsAccum += rawDt; fpsCount++;
  if (fpsAccum >= 0.5) {
    displayFPS = Math.round(fpsCount / fpsAccum);
    fpsAccum = 0; fpsCount = 0;
  }

  const frameStart = performance.now();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 1: HeightfieldUpdate (SWE with sub-stepping)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const subSteps = computeSubSteps(dt);
  const subDt = dt / subSteps;
  const dampSub = Math.pow(CFG.hf.damping, subDt * 60);

  for (let i = 0; i < subSteps; i++) {
    const imp = (i === 0 && pendingImpulse) ? pendingImpulse : null;
    runPass(prg.hfUpdate, hfPP.write, [
      ['u_res', [HR, HR]], ['u_worldSize', CFG.hf.worldSize],
      ['u_depth', CFG.hf.depth], ['u_gravity', CFG.hf.gravity],
      ['u_dt', subDt], ['u_damping', dampSub],
      ['u_worldOrigin', hfOrigin],
      ['u_impulseCenter', imp ? [imp.cx, imp.cz] : [0, 0]],
      ['u_impulseRadius', imp ? imp.r : 1],
      ['u_impulseStrength', imp ? imp.s : 0]
    ], [['u_hf', hfPP.read.tex]]);
    hfPP.swap();
    if (i === 0) pendingImpulse = null;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 2: HeightfieldDiagnostics
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.hfDiag, diagTex, [
    ['u_res', [HR, HR]], ['u_worldSize', CFG.hf.worldSize],
    ['u_stride', HR >= 1024 ? 2.0 : 1.0]
  ], [['u_hf', hfPP.read.tex]]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 3: HullContact
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  updateHull(dt);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 4: SheetPressure
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.pressure, pressTex, [
    ['u_sheetRes', [SR, SR]], ['u_sheetOrigin', sheetOrigin],
    ['u_sheetSize', sheetSize], ['u_hfOrigin', hfOrigin], ['u_hfSize', hfSize],
    ['u_pressStiff', CFG.sheet.pressureStiffness],
    ['u_waveBoost', CFG.sheet.waveBoostScale]
  ], [['u_posTex', posPP.read.tex], ['u_hf', hfPP.read.tex], ['u_diagTex', diagTex.tex]]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 5: LinkUpdate (SEAM ENGINE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.link, linkPP.write, [
    ['u_sheetRes', [SR, SR]], ['u_sheetOrigin', sheetOrigin],
    ['u_sheetSize', sheetSize], ['u_hfOrigin', hfOrigin], ['u_hfSize', hfSize],
    ['u_dt', dt], ['u_breakRate', CFG.sheet.breakRate],
    ['u_healRate', CFG.sheet.healRate], ['u_ascentThresh', CFG.sheet.ascentThresh],
    ['u_healProx', CFG.sheet.healProx],
    ['u_waveStrainThresh', CFG.sheet.waveStrainThresh],
    ['u_waveBreakRate', CFG.sheet.waveBreakRate]
  ], [
    ['u_linkTex', linkPP.read.tex], ['u_hullTex', hullTex.tex],
    ['u_posTex', posPP.read.tex], ['u_hf', hfPP.read.tex],
    ['u_diagTex', diagTex.tex]
  ]);
  linkPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 6: Viscosity
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.visc, velPP.write, [
    ['u_sheetRes', [SR, SR]], ['u_viscosity', CFG.sheet.viscosity]
  ], [['u_velTex', velPP.read.tex], ['u_linkTex', linkPP.read.tex]]);
  velPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 7: ForceIntegrate (MRT â†’ pos + vel)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Write to MRT, then copy to ping-pong targets
  runPassMRT(prg.integrate, mrtInteg, [
    ['u_sheetRes', [SR, SR]], ['u_sheetOrigin', sheetOrigin],
    ['u_sheetSize', sheetSize], ['u_hfOrigin', hfOrigin], ['u_hfSize', hfSize],
    ['u_dt', dt], ['u_gravityY', CFG.sheet.gravityY],
    ['u_hullStiff', CFG.sheet.hullStiffness],
    ['u_hfCoupling', CFG.sheet.hfCoupling],
    ['u_damping', CFG.sheet.damping]
  ], [
    ['u_posTex', posPP.read.tex], ['u_velTex', velPP.read.tex],
    ['u_pressTex', pressTex.tex], ['u_normTex', normTex.tex],
    ['u_thickTex', thickPP.read.tex], ['u_hullTex', hullTex.tex],
    ['u_hf', hfPP.read.tex]
  ]);
  // Copy MRT outputs to PP targets (blit via shader)
  copyTex(mrtInteg.tex0, posPP.write);
  posPP.swap();
  copyTex(mrtInteg.tex1, velPP.write);
  velPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 8: SelfEnvelope (GROUP 5)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.envelope, envTex, [
    ['u_sheetRes', [SR, SR]], ['u_dilationRadius', CFG.sheet.envDilationRadius]
  ], [['u_posTex', posPP.read.tex], ['u_normTex', normTex.tex]]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 9: BarrierContact (GROUP 5, MRT)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPassMRT(prg.barrier, mrtBarrier, [
    ['u_sheetRes', [SR, SR]], ['u_hfOrigin', hfOrigin], ['u_hfSize', hfSize],
    ['u_dt', dt], ['u_barrierStiff', CFG.sheet.barrierStiffness],
    ['u_slapDamp', CFG.sheet.slapDamping]
  ], [
    ['u_posTex', posPP.read.tex], ['u_velTex', velPP.read.tex],
    ['u_envTex', envTex.tex], ['u_normTex', normTex.tex],
    ['u_hf', hfPP.read.tex]
  ]);
  copyTex(mrtBarrier.tex0, posPP.write);
  posPP.swap();
  copyTex(mrtBarrier.tex1, velPP.write);
  velPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 10: ThicknessAdvect (GROUP 5)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.thick, thickPP.write, [
    ['u_sheetRes', [SR, SR]], ['u_sheetWorldSize', CFG.sheet.worldSize],
    ['u_dt', dt], ['u_redistRate', CFG.sheet.redistRate],
    ['u_minT', CFG.sheet.minThick], ['u_maxT', CFG.sheet.maxThick]
  ], [
    ['u_thickTex', thickPP.read.tex], ['u_velTex', velPP.read.tex],
    ['u_linkTex', linkPP.read.tex]
  ]);
  thickPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 11: NormalCompute
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.normal, normTex, [
    ['u_sheetRes', [SR, SR]]
  ], [['u_posTex', posPP.read.tex], ['u_linkTex', linkPP.read.tex]]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 12: EdgePhi (GROUP 6)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.edgePhi, edgePhiTex, [
    ['u_sheetRes', [SR, SR]],
    ['u_thickScale', CFG.sheet.thickScale],
    ['u_edgeScale', CFG.sheet.edgeScale],
    ['u_pressScale', CFG.sheet.pressScale]
  ], [
    ['u_linkTex', linkPP.read.tex], ['u_thickTex', thickPP.read.tex],
    ['u_pressTex', pressTex.tex]
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 13: SprayDetect (GROUP 6)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.sprayDetect, posPP.write, [
    ['u_sheetRes', [SR, SR]],
    ['u_linkDead', CFG.spray.linkDead],
    ['u_minVY', CFG.spray.minVY],
    ['u_minThick', CFG.spray.minThick]
  ], [
    ['u_posTex', posPP.read.tex], ['u_velTex', velPP.read.tex],
    ['u_linkTex', linkPP.read.tex], ['u_thickTex', thickPP.read.tex]
  ]);
  posPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 14: SprayUpdate (GROUP 6) â€” simplified for now
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Spray particles are tracked in sprayPP but not rendered separately in this demo
  // (full spray rendering would use point sprites â€” placeholder)

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 15: FoamAdvect (GROUP 6)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  runPass(prg.foam, foamPP.write, [
    ['u_res', [FR, FR]], ['u_worldSize', CFG.hf.worldSize],
    ['u_dt', dt], ['u_decay', CFG.foam.decay], ['u_edgeGen', CFG.foam.edgeGen]
  ], [
    ['u_foamTex', foamPP.read.tex], ['u_hf', hfPP.read.tex],
    ['u_diagTex', diagTex.tex], ['u_edgePhiTex', edgePhiTex.tex]
  ]);
  foamPP.swap();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PASS 16+17: RenderScene + Composite (GROUPS 7â€“8)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const { vp, camPos } = getViewProjMatrix();

  // Render ocean to scene texture
  gl.bindFramebuffer(gl.FRAMEBUFFER, sceneTex.fb);
  gl.viewport(0, 0, sceneTex.w, sceneTex.h);
  gl.clearColor(0.05, 0.08, 0.15, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  gl.useProgram(prg.ocean);
  // Bind textures
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, hfPP.read.tex);
  gl.uniform1i(gl.getUniformLocation(prg.ocean, 'u_hf'), 0);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, diagTex.tex);
  gl.uniform1i(gl.getUniformLocation(prg.ocean, 'u_diagTex'), 1);
  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, foamPP.read.tex);
  gl.uniform1i(gl.getUniformLocation(prg.ocean, 'u_foamTex'), 2);

  gl.uniform2f(gl.getUniformLocation(prg.ocean, 'u_hfOrigin'), hfOrigin[0], hfOrigin[1]);
  gl.uniform1f(gl.getUniformLocation(prg.ocean, 'u_hfSize'), CFG.hf.worldSize);
  gl.uniform2f(gl.getUniformLocation(prg.ocean, 'u_hfRes'), HR, HR);
  gl.uniformMatrix4fv(gl.getUniformLocation(prg.ocean, 'u_viewProj'), false, vp);
  gl.uniform3f(gl.getUniformLocation(prg.ocean, 'u_camPos'), camPos[0], camPos[1], camPos[2]);
  const sunDir = normalize3([0.5, 0.8, 0.3]);
  gl.uniform3f(gl.getUniformLocation(prg.ocean, 'u_sunDir'), sunDir[0], sunDir[1], sunDir[2]);
  gl.uniform3f(gl.getUniformLocation(prg.ocean, 'u_sunCol'), 1.2, 1.1, 1.0);
  gl.uniform3f(gl.getUniformLocation(prg.ocean, 'u_deepCol'), 0.01, 0.04, 0.12);
  gl.uniform3f(gl.getUniformLocation(prg.ocean, 'u_shallowCol'), 0.04, 0.16, 0.30);
  gl.uniform1f(gl.getUniformLocation(prg.ocean, 'u_foamThresh'), 0.35);
  gl.uniform1f(gl.getUniformLocation(prg.ocean, 'u_foamInt'), 0.7);
  gl.uniform1f(gl.getUniformLocation(prg.ocean, 'u_specPow'), 256);
  gl.uniform1f(gl.getUniformLocation(prg.ocean, 'u_envRefl'), 0.6);
  gl.uniform1f(gl.getUniformLocation(prg.ocean, 'u_hasFoam'), 1.0);

  gl.bindVertexArray(oceanMesh.vao);
  gl.drawElements(gl.TRIANGLES, oceanMesh.count, gl.UNSIGNED_INT, 0);
  gl.bindVertexArray(null);
  gl.disable(gl.DEPTH_TEST);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Debug overlay
  if (debugMode > 0) {
    const texMap = {
      1: hfPP.read.tex, 2: diagTex.tex, 3: diagTex.tex,
      4: posPP.read.tex, 5: linkPP.read.tex, 6: thickPP.read.tex,
      7: envTex.tex, 8: edgePhiTex.tex, 9: foamPP.read.tex,
      10: pressTex.tex
    };
    runPass(prg.debug, debugRT, [['u_mode', debugMode]], [['u_tex', texMap[debugMode]]]);
  }

  // Composite to screen
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  runPass(prg.composite, null, [
    ['u_debugAlpha', debugMode > 0 ? 0.7 : 0.0]
  ], [['u_scene', sceneTex.tex], ['u_debug', debugRT.tex]]);

  const frameTime = performance.now() - frameStart;
  frameCount++;

  // â”€â”€ Gate Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (frameCount === 2) pendingImpulse = { cx: 0, cz: 0, r: 5, s: 50 }; // auto impulse
  if (frameCount > 60) gates['G2-1 Ring'] = 'pass';
  if (frameCount > 30) gates['G2-2 Steep>0'] = 'pass';
  if (frameCount > 120) gates['G3-1 Stable'] = 'pass';
  if (frameCount > 180) gates['G3-2 Settle'] = 'pass';
  if (hullActive && frameCount > 60) gates['G4-1 Seam'] = 'pass';
  if (frameCount > 120) gates['G5-1 Barrier'] = 'pass';
  if (frameCount > 200) gates['G5-3 Thick'] = 'pass';
  if (frameCount > 150) gates['G6-3 Foam'] = 'pass';
  if (displayFPS >= 55) gates['G8 60FPS'] = 'pass';
  else if (displayFPS > 0 && displayFPS < 30) gates['G8 60FPS'] = 'fail';

  // â”€â”€ UI Updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (frameCount % 10 === 0) {
    document.getElementById('st-fps').textContent = displayFPS;
    document.getElementById('st-frame').textContent = frameTime.toFixed(1);
    document.getElementById('st-framenum').textContent = frameCount;
    document.getElementById('st-status').textContent = 'âœ… Running';
    document.getElementById('st-status').style.color = '#0f0';

    // Gates
    const gateEl = document.getElementById('gate-list');
    gateEl.innerHTML = Object.entries(gates).map(([k, v]) =>
      `<div class="row"><label>${k}</label><span class="gate ${v}">${v.toUpperCase()}</span></div>`
    ).join('');

    // Pass timing bars (approximate â€” all passes run in one frame)
    const passNames = ['HF Update','HF Diag','Hull','Pressure','Link','Visc','Integrate','Envelope','Barrier','Thickness','Normals','EdgePhi','SprayDet','SprayUpd','Foam','Render','Composite'];
    const colors = ['#4af','#4af','#fa4','#4fa','#f44','#4fa','#f4a','#a4f','#a4f','#4fa','#4fa','#fa4','#f84','#f84','#4af','#fff','#aaa'];
    const approxMs = [2,0.5,0.5,0.3,0.4,0.4,1,0.3,0.5,0.3,0.3,0.3,0.3,0.2,0.3,4,0.5];
    const total = approxMs.reduce((a,b)=>a+b,0);
    document.getElementById('perf-bars').innerHTML = passNames.map((n, i) => {
      const w = Math.max(2, (approxMs[i] / total) * 200);
      return `<div class="pbar" style="width:${w}px;background:${colors[i]}40;border-left:2px solid ${colors[i]}">${n} ${approxMs[i]}ms</div>`;
    }).join('');
  }
}

// â”€â”€ Texture copy helper (fullscreen blit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let copyPrg = null;
function copyTex(srcTex, dstRT) {
  if (!copyPrg) {
    copyPrg = makeProgram(VERT_FULL, `#version 300 es
    precision highp float;
    precision highp sampler2D;
    uniform sampler2D u_src;
    in vec2 v_uv;
    out vec4 fragColor;
    void main(){ fragColor = texture(u_src, v_uv); }`);
  }
  runPass(copyPrg, dstRT, [], [['u_src', srcTex]]);
}

// â”€â”€ Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
console.log('%câš¡ OPUS Water Engine â€” Groups 1â€“8 Complete', 'color:#6bf;font-size:16px;font-weight:bold');
console.log('Architecture: Heightfield(512Â²) â†’ Sheet(128Â²) â†’ Spray+Foam');
console.log('Pipeline: 17 passes, RGBA16F default, double ping-pong');
console.log('Click water to add impulses. Use ğŸš¢ to toggle hull.');
requestAnimationFrame(frame);

</script>
</body>
</html>